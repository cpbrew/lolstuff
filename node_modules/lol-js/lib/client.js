// Generated by CoffeeScript 1.9.0
(function() {
  var Client, EventEmitter, MAX_RETRIES_ON_RIOT_API_UNAVAILABLE, ONE_MONTH_IN_SECONDS, Promise, RateLimiter, TIME_TO_WAIT_FOR_RIOT_API_IN_MS, async, fs, ld, path, querystring, utils,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  querystring = require('querystring');

  ld = require('lodash');

  fs = require('fs');

  path = require('path');

  async = require('async');

  Promise = require('es6-promise').Promise;

  utils = require('./utils');

  RateLimiter = require('./rateLimiter');

  MAX_RETRIES_ON_RIOT_API_UNAVAILABLE = 10;

  TIME_TO_WAIT_FOR_RIOT_API_IN_MS = 100;

  ONE_MONTH_IN_SECONDS = 30 * 24 * 60 * 60;

  module.exports = Client = (function(_super) {
    __extends(Client, _super);

    Client.prototype.constants = require('./constants');

    function Client(options) {
      var rateLimitOptions, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      this.Promise = (_ref = options.Promise) != null ? _ref : Promise;
      if (options.apiKey == null) {
        throw new Error('apiKey is required.');
      }
      this.apiKey = options.apiKey;
      this.defaultRegion = (_ref1 = options.defaultRegion) != null ? _ref1 : 'na';
      this.cacheTTL = ld.defaults({}, options.cacheTTL, {
        short: 60 * 5,
        long: ONE_MONTH_IN_SECONDS,
        flex: ONE_MONTH_IN_SECONDS
      });
      if (options.cache != null) {
        this.cache = {
          get: (function(_this) {
            return function(params) {
              return new _this.Promise(function(resolve, reject) {
                var answer;
                return answer = options.cache.get(params, function(err, answer) {
                  if (err != null) {
                    _this._stats.errors++;
                    _this.emit('cacheGetError', err);
                    return resolve(null);
                  }
                  if (answer == null) {
                    _this._stats.misses++;
                  } else {
                    _this._stats.hits++;
                    if (answer.cacheTime != null) {
                      resolve(answer);
                    } else {
                      if (answer === 'none') {
                        answer = null;
                      }
                      resolve({
                        value: answer,
                        cacheTime: 0,
                        ttl: 0
                      });
                    }
                  }
                  return resolve(answer);
                });
              });
            };
          })(this),
          set: (function(_this) {
            return function(params, value) {
              var cacheTime, cacheValue, err, ttl, _ref2;
              try {
                cacheTime = Date.now();
                ttl = (_ref2 = params.ttl) != null ? _ref2 : _this.cacheTTL.short;
                cacheValue = {
                  value: value,
                  cacheTime: cacheTime,
                  ttl: ttl
                };
                if (ttl < _this.cacheTTL.flex) {
                  ttl = _this.cacheTTL.flex;
                }
                if (params.ttl == null) {
                  params = ld.extend({}, params, {
                    ttl: ttl
                  });
                }
                return options.cache.set(params, cacheValue);
              } catch (_error) {
                err = _error;
                _this._stats.errors++;
                return _this.emit('cacheSetError', err);
              }
            };
          })(this),
          destroy: function() {
            var _base;
            return typeof (_base = options.cache).destroy === "function" ? _base.destroy() : void 0;
          }
        };
      } else {
        this.cache = {
          get: (function(_this) {
            return function(params) {
              return new _this.Promise(function(resolve, reject) {
                return resolve(null);
              });
            };
          })(this),
          set: function() {},
          destroy: function() {}
        };
      }
      rateLimitOptions = (_ref2 = options.rateLimit) != null ? _ref2 : [
        {
          time: 10,
          limit: 10
        }, {
          time: 600,
          limit: 500
        }
      ];
      this._rateLimiter = new RateLimiter(rateLimitOptions, this.Promise);
      this._queuedRequests = [];
      this._processingRequests = false;
      this._stats = {
        hits: 0,
        misses: 0,
        errors: 0,
        rateLimitErrors: 0,
        queueHighWaterMark: 0,
        riotApiUnavailable: 0
      };
      this._request = require('request');
    }

    Client.prototype.destroy = function() {
      return this.cache.destroy();
    };

    Client.prototype.getStats = function() {
      return ld.merge({}, this._stats, {
        queueLength: this._queuedRequests.length
      });
    };

    Client.prototype._sleepAsync = function(durationInMs) {
      return new this.Promise(function(resolve, reject) {
        return setTimeout((function() {
          return resolve();
        }), durationInMs);
      });
    };

    Client.prototype._doRequest = function(params) {
      var allowRetries, caller, retries, url, _ref;
      if (params.retries == null) {
        params.retries = 0;
      }
      url = params.url, caller = params.caller, retries = params.retries;
      allowRetries = (_ref = params.allowRetries) != null ? _ref : true;
      return new this.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._request({
            uri: url,
            gzip: true
          }, function(err, response, body) {
            try {
              if (err != null) {
                return reject(err);
              }
              if (response.statusCode === 429) {
                _this._stats.rateLimitErrors++;
                params.retries = 0;
                return _this._rateLimiter.wait().then(function() {
                  return _this._doRequest(params).then(resolve, reject);
                });
              } else if (response.statusCode === 404) {
                return resolve(null);
              } else if (response.statusCode === 503) {
                _this._riotApiUnavailable++;
                if (allowRetries && retries < MAX_RETRIES_ON_RIOT_API_UNAVAILABLE) {
                  return _this._sleepAsync(TIME_TO_WAIT_FOR_RIOT_API_IN_MS).then(function() {
                    return _this._rateLimiter.wait();
                  }).then(function() {
                    params.retries++;
                    return _this._doRequest(params).then(resolve, reject);
                  })["catch"](reject);
                } else {
                  err = new Error("Riot API is temporarily unavailable");
                  err.statusCode = response.statusCode;
                  err.caller = caller;
                  return reject(err);
                }
              } else if (response.statusCode !== 200) {
                err = new Error("Error calling " + params.caller + ": " + response.statusCode);
                err.statusCode = response.statusCode;
                err.caller = caller;
                return reject(err);
              } else {
                return resolve(JSON.parse(body));
              }
            } catch (_error) {
              err = _error;
              return reject(err);
            }
          });
        };
      })(this));
    };

    Client.prototype._startRequestWorker = function() {
      var doWork;
      if (this._processingRequests) {
        return;
      }
      this._processingRequests = true;
      doWork = (function(_this) {
        return function() {
          if (_this._queuedRequests.length === 0) {
            return _this._processingRequests = false;
          } else {
            return _this._rateLimiter.wait().then(function() {
              var allowRetries, caller, reject, resolve, url, _ref;
              setImmediate(doWork);
              _ref = _this._queuedRequests.shift(), url = _ref.url, caller = _ref.caller, allowRetries = _ref.allowRetries, resolve = _ref.resolve, reject = _ref.reject;
              return _this._doRequest({
                url: url,
                caller: caller,
                allowRetries: allowRetries
              }).then(resolve, reject);
            })["catch"](function(err) {
              var _ref;
              console.err("Fatal error in lol-js worker");
              console.err((_ref = err.stack) != null ? _ref : err);
              return process.exit(-1);
            });
          }
        };
      })(this);
      return setImmediate(doWork);
    };

    Client.prototype._riotRequest = function(params, haveCached) {
      var answer, caller, existingRequest, promise, queryParams, queryString, queueItem, requestId, url, _ref;
      if (params.queryParams) {
        queryParams = ld(params.queryParams).map(function(v, k) {
          return [k, v];
        }).sortBy(0).zipObject().value();
        queryString = querystring.stringify(queryParams);
      } else {
        queryString = null;
      }
      requestId = params.url + "?" + (queryString != null ? queryString : '');
      url = "" + requestId + (queryString != null ? '&' : '') + "api_key=" + this.apiKey;
      caller = params.caller;
      if (!((_ref = params.rateLimit) != null ? _ref : true)) {
        answer = this._doRequest({
          url: url,
          caller: caller,
          allowRetries: !haveCached
        });
      } else if ((existingRequest = ld.find(this._queuedRequests, {
        requestId: requestId
      })) != null) {
        answer = existingRequest.promise;
      } else {
        queueItem = {
          requestId: requestId,
          url: url,
          caller: caller,
          allowRetries: !haveCached
        };
        answer = promise = new this.Promise(function(resolve, reject) {
          queueItem.resolve = resolve;
          return queueItem.reject = reject;
        });
        queueItem.promise = promise;
        this._queuedRequests.push(queueItem);
        this._stats.queueHighWaterMark = Math.max(this._stats.queueHighWaterMark, this._queuedRequests.length);
        this._startRequestWorker();
      }
      return answer;
    };

    Client.prototype._validateCacheParams = function(cacheParams) {
      var key, _i, _len, _ref;
      _ref = ['key', 'api', 'objectType', 'region', 'params'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (!(key in cacheParams)) {
          throw new Error("Missing " + key + " in cacheParams.");
        }
      }
      if (!'ttl' in cacheParams) {
        return cacheParams.ttl != null ? cacheParams.ttl : cacheParams.ttl = this.cacheTTL.short;
      }
    };

    Client.prototype._riotRequestWithCache = function(params, cacheParams, options) {
      var cachedAnswer;
      if (options == null) {
        options = {};
      }
      this._validateCacheParams(cacheParams);
      cachedAnswer = null;
      return this.cache.get(cacheParams).then((function(_this) {
        return function(cachedAnswer) {
          var answer, cacheTime, expires, ttl, value, _ref;
          _ref = cachedAnswer != null ? cachedAnswer : {}, value = _ref.value, cacheTime = _ref.cacheTime, ttl = _ref.ttl;
          if (ttl == null) {
            ttl = 0;
          }
          expires = (cacheTime != null ? cacheTime : 0) + (ttl * 1000);
          if ((cachedAnswer == null) || (expires < Date.now())) {
            answer = _this._riotRequest(params, cachedAnswer != null).then(function(result) {
              if (options.preCache != null) {
                return options.preCache(result);
              } else {
                return result;
              }
            }).then(function(result) {
              _this.cache.set(cacheParams, result);
              return result;
            })["catch"](function(err) {
              if (cachedAnswer != null) {
                return cachedAnswer.value;
              } else {
                throw err;
              }
            });
          } else {
            answer = cachedAnswer.value;
          }
          return answer;
        };
      })(this));
    };

    Client.prototype._riotMultiGet = function(params, options) {
      var answer, baseUrl, cacheResultFn, caller, getCacheParamsFn, ids, maxObjs, missingObjects, queryParams, region, urlSuffix, _ref;
      caller = params.caller, baseUrl = params.baseUrl, ids = params.ids, urlSuffix = params.urlSuffix, getCacheParamsFn = params.getCacheParamsFn, cacheResultFn = params.cacheResultFn, queryParams = params.queryParams, maxObjs = params.maxObjs;
      region = (_ref = options != null ? options.region : void 0) != null ? _ref : this.defaultRegion;
      if (!ld.isArray(ids)) {
        ids = [ids];
      }
      answer = {};
      missingObjects = [];
      return this.Promise.all(ids.map((function(_this) {
        return function(id) {
          return new _this.Promise(function(resolve, reject) {
            var cacheParams;
            cacheParams = getCacheParamsFn(_this, region, id, options);
            _this._validateCacheParams(cacheParams);
            return _this.cache.get(cacheParams).then(function(object) {
              return resolve({
                id: id,
                cacheParams: cacheParams,
                object: object
              });
            }, reject);
          });
        };
      })(this))).then((function(_this) {
        return function(objects) {
          var cacheParams, groups, i, id, object, _i, _len, _ref1;
          for (_i = 0, _len = objects.length; _i < _len; _i++) {
            _ref1 = objects[_i], id = _ref1.id, cacheParams = _ref1.cacheParams, object = _ref1.object;
            if ((object == null) || (((object != null ? object.expires : void 0) != null) && object.expires < Date.now())) {
              missingObjects.push({
                id: id,
                cacheParams: cacheParams,
                cached: object
              });
            } else {
              answer[id] = object.value;
            }
          }
          if (missingObjects.length === 0) {
            return answer;
          } else {
            groups = (function() {
              var _j, _ref2, _results;
              _results = [];
              for (i = _j = 0, _ref2 = Math.ceil(missingObjects.length / maxObjs); 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                _results.push(missingObjects.slice(i * maxObjs, i * maxObjs + maxObjs));
              }
              return _results;
            })();
            return _this.Promise.all(groups.map(function(group) {
              var haveCached;
              haveCached = ld.every(group, function(g) {
                return g.cached != null;
              });
              return _this._riotRequest({
                caller: caller,
                region: region,
                url: baseUrl + "/" + (ld.pluck(group, "id").join(",")) + (urlSuffix != null ? urlSuffix : ''),
                queryParams: queryParams
              }, haveCached).then(function(fetchedObjects) {
                var _j, _len1, _ref2, _ref3;
                if (fetchedObjects == null) {
                  fetchedObjects = {};
                }
                for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
                  _ref2 = group[_j], id = _ref2.id, cacheParams = _ref2.cacheParams;
                  answer[id] = (_ref3 = fetchedObjects[id]) != null ? _ref3 : null;
                  if ((answer[id] != null) && (typeof cacheResultsFn !== "undefined" && cacheResultsFn !== null)) {
                    cacheResultFn(_this, region, answer[id], options);
                  } else {
                    _this.cache.set(cacheParams, answer[id]);
                  }
                }
                return null;
              })["catch"](function(err) {
                var cached, _j, _len1, _ref2;
                for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
                  _ref2 = group[_j], id = _ref2.id, cached = _ref2.cached;
                  if (cached == null) {
                    throw err;
                  }
                  answer[id] = cached.value;
                }
                return null;
              });
            }));
          }
        };
      })(this)).then(function() {
        return answer;
      });
    };

    Client.prototype._makeUrl = function(region, api) {
      return "https://" + region + ".api.pvp.net/api/lol/" + region + "/" + api.version + "/" + api.name;
    };

    return Client;

  })(EventEmitter);

  (function() {
    var api, moduleFile, moduleName, _i, _len, _ref;
    _ref = fs.readdirSync(path.join(__dirname, "api"));
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      moduleFile = _ref[_i];
      moduleName = path.basename(moduleFile, path.extname(moduleFile));
      api = require("./api/" + moduleName);
      ld.extend(Client.prototype, api.methods);
    }
    return utils.depromisifyAll(Client.prototype, {
      isPrototype: true
    });
  })();

}).call(this);
