// Generated by CoffeeScript 1.9.0
(function() {
  var api, assert, ld, lolStaticDataApi, promiseToCb, summonerApi;

  assert = require('assert');

  ld = require('lodash');

  summonerApi = require('./summoner');

  lolStaticDataApi = require('./lolStaticData');

  promiseToCb = require('../utils').promiseToCb;

  api = exports.api = {
    fullname: "match-v2.2",
    name: "match",
    version: "v2.2"
  };

  exports.methods = {
    getMatchAsync: function(matchId, options) {
      var cacheParams, region, requestOptions, requestParams, _ref;
      if (options == null) {
        options = {};
      }
      options = ld.defaults({}, options, {
        region: this.defaultRegion,
        includeTimeline: false
      });
      region = (_ref = options.region) != null ? _ref : this.defaultRegion;
      requestParams = {
        caller: "getMatch",
        region: region,
        url: (this._makeUrl(region, api)) + "/" + matchId,
        queryParams: {
          includeTimeline: options.includeTimeline
        }
      };
      cacheParams = {
        key: api.fullname + "-match-" + region + "-" + matchId + "-" + options.includeTimeline,
        region: region,
        api: api,
        ttl: this.cacheTTL.long,
        objectType: 'match',
        params: {
          matchId: matchId,
          includeTimeline: options.includeTimeline
        }
      };
      requestOptions = {};
      if (options.players != null) {
        requestOptions.preCache = (function(_this) {
          return function(match) {
            if (match == null) {
              return match;
            }
            return _this.populateMatchAsync(match, options.players, options).then(function() {
              return match;
            });
          };
        })(this);
      }
      return this._riotRequestWithCache(requestParams, cacheParams, requestOptions);
    },
    populateMatchAsync: function(match, players, options) {
      if (options == null) {
        options = {};
      }
      assert(ld.isArray(players), "'players' must be an array!");
      if (ld.every(match.participantIdentities, "player")) {
        return this.Promise.resolve(0);
      }
      return this._loadPlayersAsync(players, options).then(function(playerData) {
        var participant, participantIdentitiesById, participantIdentity, player, populated, _i, _len, _ref;
        populated = 0;
        participantIdentitiesById = ld.indexBy(match.participantIdentities, "participantId");
        _ref = match.participants;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          participant = _ref[_i];
          participantIdentity = participantIdentitiesById[participant.participantId];
          if (!participantIdentity.player) {
            player = ld.find(playerData, function(p) {
              return p.championId === participant.championId && p.teamId === participant.teamId;
            });
            if (player != null) {
              populated++;
              participantIdentity.player = {
                profileIcon: player.summoner.profileIconId,
                matchHistoryUri: null,
                summonerName: player.summoner.name,
                summonerId: player.summoner.id
              };
            }
          }
        }
        return populated;
      });
    },
    _loadPlayersAsync: function(players, options) {
      if (options == null) {
        options = {};
      }
      return this.Promise.resolve().then((function(_this) {
        return function() {
          var summonerIds, summonerNames, summonersById, summonersByIdPromise, summonersByNamePromise;
          players.forEach(function(player) {
            if ((player.summonerId == null) && (player.summonerName == null)) {
              throw new Error("player record has no summonerId and no summonerName");
            }
          });
          assert.equal(summonerApi.api.version, "v1.4", "Can't load players - summoner API version has changed.");
          assert.equal(lolStaticDataApi.api.version, "v1.2", "Can't load players - lol-static-data API version has changed.");
          summonerIds = ld(players).filter('summonerId').map('summonerId').value();
          summonersByIdPromise = summonerIds.length > 0 ? _this.getSummonersByIdAsync(summonerIds, options) : _this.Promise.resolve({});
          summonerNames = ld(players).reject('summonerId').map("summonerName").value();
          summonersByNamePromise = summonerNames.length > 0 ? _this.getSummonersByNameAsync(summonerNames, options) : _this.Promise.resolve({});
          summonersById = null;
          return summonersByIdPromise.then(function(result) {
            summonersById = result;
            return summonersByNamePromise;
          }).then(function(summonersByName) {
            return _this.Promise.all(players.map(function(player) {
              var summoner;
              summoner = null;
              return _this.Promise.resolve().then(function() {
                summoner = player.summonerId != null ? summonersById[player.summonerId] : summonersByName[player.summonerName];
                return (player.championId != null ? {
                  id: player.championId
                } : this.getChampionByNameAsync(player.championKey, options));
              }).then(function(champion) {
                var _ref;
                if ((summoner != null) && (champion != null)) {
                  return {
                    summoner: summoner,
                    championId: champion.id,
                    teamId: (_ref = player.teamId) != null ? _ref : this.teamNameToId(player.team)
                  };
                } else {
                  return null;
                }
              });
            })).then(function(answer) {
              return answer.filter(function(x) {
                return x !== null;
              });
            });
          });
        };
      })(this));
    },
    getTeamIdForSummonerId: function(match, summonerId) {
      var answer, participant, participantId, participantIdentity;
      participantIdentity = ld.find(match.participantIdentities, {
        player: {
          summonerId: summonerId
        }
      });
      if (participantIdentity == null) {
        answer = null;
      } else {
        participantId = participantIdentity.participantId;
        participant = ld.find(match.participants, {
          participantId: participantId
        });
        answer = participant.teamId;
      }
      return answer;
    }
  };

}).call(this);
